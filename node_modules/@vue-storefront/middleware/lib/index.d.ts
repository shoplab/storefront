import { Express, Request, Response } from 'express';
import { HelmetOptions } from 'helmet';

type ParamType = string | number | symbol;
type TObject = Record<string, any>;
type CustomQuery<T extends ParamType = string> = {
    [P in T]?: string;
} & {
    metadata?: unknown;
};
interface ContextQueryParams {
    query: string;
    variables: TObject;
}
type ContextQuery<T extends ParamType = string> = {
    [Key in T]: ContextQueryParams;
};
type CustomQueryFunction<T = any> = ({ query, variables, metadata, }: {
    query: string;
    variables: T;
    metadata: unknown;
}) => {
    query: string;
    variables: T;
    metadata?: unknown;
};
type ComposableFunctionArgs<T> = T & {
    customQuery?: CustomQuery;
};
type ApiClientMethod = (...args: any) => Promise<any>;
type ApiClientMethods<T> = {
    [K in keyof T]: T[K] extends (...args: any) => any ? (...args: [...Parameters<T[K]>, CustomQuery?]) => ReturnType<T[K]> : T[K];
};
type AxiosError = {
    isAxiosError: boolean;
    response: {
        status: number;
    };
};
type ApolloError = {
    networkError?: number;
    code?: string | number;
};
type StatusCode = number | null;
type UnknownError<T extends string> = {
    [K in T]?: number;
} & {
    [x: string]: UnknownError<T> | any;
};
type ErrorObject<T extends string> = AxiosError | ApolloError | UnknownError<T>;

interface ClientContext<CLIENT = any, CONFIG = any> {
    client: CLIENT;
    config: CONFIG;
    [x: string]: any;
}
interface IntegrationContext<CLIENT = any, CONFIG = any, API = any> {
    client: CLIENT;
    config: CONFIG;
    api: API;
    [x: string]: any;
}
interface Context<CLIENT = any, CONFIG = any, API = any> {
    [x: string]: IntegrationContext<CLIENT, CONFIG, API> | any;
}
type PlatformApi = {
    [functionName: string]: (context: Context, ...args: any[]) => Promise<any>;
};
type ContextedPlatformApi<T extends PlatformApi> = {
    [P in keyof T]: T[P] extends (context: Context, ...arg: infer X) => Promise<any> ? (...arg: X) => Promise<any> : never;
};
interface FactoryParams<API extends PlatformApi = any> {
    provide?: (context: Context) => any;
    api?: Partial<API>;
}
interface ApiInstance<CONFIG, API, CLIENT> {
    api: API;
    client: CLIENT;
    settings: CONFIG;
}
type CreateApiClientFn<CONFIG extends ApiClientConfig, API extends ApiMethods> = {
    <T extends ApiClientConfig, C>(givenConfig: CONFIG, customApi?: ApiMethods): ApiInstance<T, API & ApiMethods, C>;
    _predefinedExtensions?: ApiClientExtension<API>[];
};
interface ApiClientFactoryParams<CONFIG extends ApiClientConfig, API extends ApiMethods, CLIENT = any> {
    api: API;
    isProxy?: boolean;
    onCreate: (config: CONFIG, headers?: Record<string, string>) => {
        client: CLIENT;
        config: ApiClientConfig;
    };
    extensions?: ApiClientExtension<API>[];
}
interface ApiClientFactory<CONFIG extends ApiClientConfig = any, API extends ApiMethods = {}> {
    createApiClient: CreateApiClientFn<CONFIG, API>;
    /**
     * Sets up integration config, runs once.
     */
    init?: (configuration: TObject) => TObject;
}
type CreateApiProxyFn = <CONFIG, API, CLIENT>(givenConfig: any, customApi?: any) => ApiInstance<CONFIG, API, CLIENT>;
interface ApiClientConfig<CLIENT = any> {
    client?: CLIENT;
    extensions?: ApiClientExtension[];
    [x: string]: any;
}

type ApiMethods = Record<string, ApiClientMethod>;
type ApiClientMethodWithContext<CONTEXT> = (context: CONTEXT, ...args: any) => any;
interface Integration<CONFIG extends TObject = any, API extends ApiMethods = {}, CONTEXT extends TObject = any> {
    location: string;
    configuration: CONFIG;
    extensions?: <T extends ApiClientMethodWithContext<CONTEXT>>(extensions: ApiClientExtension<API, CONTEXT>[]) => ApiClientExtension<API & T, CONTEXT>[];
    customQueries?: Record<string, CustomQueryFunction>;
    initConfig?: TObject;
}
interface RequestParams {
    integrationName: string;
    functionName: string;
}
interface IntegrationLoaded<CONFIG extends ApiClientConfig, API extends ApiMethods> {
    apiClient: ApiClientFactory<CONFIG, API>;
    initConfig: TObject;
    configuration: CONFIG;
    extensions: ApiClientExtension<API>[];
    customQueries?: Record<string, CustomQueryFunction>;
}
interface LoadInitConfigProps {
    apiClient: ApiClientFactory;
    integration: Integration;
    tag: string;
}
type IntegrationsLoaded<CONFIG extends ApiClientConfig = any, API extends ApiMethods = {}> = Record<string, IntegrationLoaded<CONFIG, API>>;
type ExtendApiMethod<API, CONTEXT> = {
    [K in keyof API]?: ApiClientMethodWithContext<CONTEXT>;
} & {
    [key: string]: ApiClientMethodWithContext<CONTEXT>;
};
interface ApiClientExtension<API = {}, CONTEXT = any> {
    name: string;
    extendApiMethods?: ExtendApiMethod<API, CONTEXT>;
    extendApp?: ({ app, configuration }: {
        app: Express;
        configuration: any;
    }) => void;
    hooks?: (req: Request, res: Response) => ApiClientExtensionHooks;
}
interface MiddlewareContext<API extends ApiMethods = {}> {
    req: Request;
    res: Response;
    extensions: ApiClientExtension<API>[];
    customQueries: Record<string, CustomQueryFunction>;
}
interface ApiContext<CONFIG, CLIENT, REQUEST, RESPONSE> {
    config: CONFIG;
    client: CLIENT;
    req: REQUEST;
    res: RESPONSE;
    extensions: any;
    customQueries: Record<string, CustomQueryFunction>;
    extendQuery: ExtendQuery;
}
type CallableContext<API extends ApiMethods> = {
    middleware: MiddlewareContext<API>;
};
interface HookParams<C> {
    configuration?: C;
}
interface CallHookParams<C> extends HookParams<C> {
    callName: string;
}
type BeforeCallArgs<T = any> = T;
type AfterCallArgs<T = any> = T;
interface BeforeCallParams<C, ARGS> extends CallHookParams<C> {
    args: BeforeCallArgs<ARGS>;
}
interface AfterCallParams<C, ARGS, RESPONSE> extends CallHookParams<C> {
    args: BeforeCallArgs<ARGS>;
    response: AfterCallArgs<RESPONSE>;
}
interface ApiClientExtensionHooks<C = any> {
    beforeCreate?: (params: HookParams<C>) => C;
    afterCreate?: (params: HookParams<C>) => C;
    beforeCall?: <ARGS>(params: BeforeCallParams<C, ARGS>) => BeforeCallArgs;
    afterCall?: <ARGS, RESPONSE>(params: AfterCallParams<C, ARGS, RESPONSE>) => AfterCallArgs;
}
interface ApplyingContextHooks<CONFIG = any> {
    before: <ARGS>(params: BeforeCallParams<CONFIG, ARGS>) => BeforeCallArgs;
    after: <ARGS, RESPONSE>(params: AfterCallParams<CONFIG, ARGS, RESPONSE>) => AfterCallArgs;
}
type ExtendQuery = <T extends ContextQuery<string>, Key extends keyof T>(customQuery: CustomQuery<Key> | null, defaults: T) => ContextQuery<Key>;
type ExtensionHookWith<T extends keyof ApiClientExtensionHooks> = WithRequired<ApiClientExtensionHooks, T>;
type ExtensionWith<T extends keyof ApiClientExtension> = WithRequired<ApiClientExtension, T>;

interface Helmet extends HelmetOptions {
    helmet?: boolean | HelmetOptions;
}
interface Integrations {
    [key: string]: Integration;
}
interface MiddlewareConfig {
    integrations: Integrations;
    helmet?: boolean | Readonly<HelmetOptions>;
}

type TODO = any;
type ObjectRecord<O> = {
    [K in keyof O]: O[K];
};
type ObjectItemRecord<V = string, K = string> = {
    [keyof in K as string]: V;
};
type PartialRecord<O> = {
    [K in keyof O]?: O[K];
};
type NullableRecord<V> = V | null;
type GetConstructorArgs<T> = T extends new (...args: infer U) => any ? U : never;
type RecordOverloadedReturnType<T> = T extends {
    (...args: any[]): infer R;
    (...args: any[]): infer R;
    (...args: any[]): infer R;
    (...args: any[]): infer R;
} ? R : T extends {
    (...args: any[]): infer R;
    (...args: any[]): infer R;
    (...args: any[]): infer R;
} ? R : T extends {
    (...args: any[]): infer R;
    (...args: any[]): infer R;
} ? R : T extends (...args: any[]) => infer R ? R : any;
type AnyFunction = (...args: any) => any;
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};

declare function createServer(config: MiddlewareConfig): Promise<Express>;

declare const apiClientFactory: <ALL_SETTINGS extends ApiClientConfig<any>, ALL_FUNCTIONS extends ApiMethods>(factoryParams: ApiClientFactoryParams<ALL_SETTINGS, ALL_FUNCTIONS, any>) => ApiClientFactory<any, ALL_FUNCTIONS>;

export { AfterCallArgs, AfterCallParams, AnyFunction, ApiClientConfig, ApiClientExtension, ApiClientExtensionHooks, ApiClientFactory, ApiClientFactoryParams, ApiClientMethod, ApiClientMethodWithContext, ApiClientMethods, ApiContext, ApiInstance, ApiMethods, ApolloError, ApplyingContextHooks, AxiosError, BeforeCallArgs, BeforeCallParams, CallHookParams, CallableContext, ClientContext, ComposableFunctionArgs, Context, ContextQuery, ContextQueryParams, ContextedPlatformApi, CreateApiClientFn, CreateApiProxyFn, CustomQuery, CustomQueryFunction, ErrorObject, ExtendApiMethod, ExtendQuery, ExtensionHookWith, ExtensionWith, FactoryParams, GetConstructorArgs, Helmet, HookParams, Integration, IntegrationContext, IntegrationLoaded, Integrations, IntegrationsLoaded, LoadInitConfigProps, MiddlewareConfig, MiddlewareContext, NullableRecord, ObjectItemRecord, ObjectRecord, ParamType, PartialRecord, PlatformApi, RecordOverloadedReturnType, RequestParams, StatusCode, TODO, TObject, UnknownError, WithRequired, apiClientFactory, createServer };
