'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * EventManager is a class that is used to emit and subscribe to events.
 *
 * @example
 * You can use it to emit an event:
 * ```typescript
 * const eventManager = new EventManager();
 * eventManager.emit('my_event_name', { foo: 'bar' });
 * ```
 *
 * You can use it to register a callback for an event:
 * ```typescript
 * const eventManager = new EventManager();
 * eventManager.register('my_event_name', (data) => {
 *   console.log(data);
 *   // { foo: 'bar' }
 *   // ...
 * });
 */
class EventManager {
    constructor() {
        this.events = {};
    }
    emit(topic, data) {
        var _a;
        const topicEvents = (_a = this.events[topic]) !== null && _a !== void 0 ? _a : [];
        topicEvents.forEach((callback) => {
            callback(data);
        });
    }
    register(topic, callback) {
        var _a;
        const topicEvents = (_a = this.events[topic]) !== null && _a !== void 0 ? _a : [];
        this.events[topic] = topicEvents.concat(callback);
    }
    unregister(topic, callback) {
        if (!Array.isArray(this.events[topic]))
            return;
        this.events[topic] = this.events[topic].filter((fn) => fn !== callback);
    }
    registerSubscribers(subscribers) {
        for (const [topic, callbacks] of Object.entries(subscribers)) {
            if (Array.isArray(callbacks)) {
                callbacks.forEach((callback) => this.register(topic, callback));
            }
            else {
                this.register(topic, callbacks);
            }
        }
    }
}
const eventManager = new EventManager();

class SDKError extends Error {
    constructor(message, cause) {
        super(message);
        this.name = 'SDKError';
        this.cause = cause;
    }
}
const handleError = (err) => {
    var _a;
    const errMsg = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : '[SDK] Error: something went wrong.';
    return new SDKError(errMsg, err);
};

/**
 * This class is responsible for managing interceptors, executing them and mapping them to the methods.
 */
class InterceptorsManager {
    /**
     * InterceptorsManager constructor
     *
     * @param config
     * @param eventManager
     */
    constructor(config, eventManager) {
        /**
         * Executes configured interceptors in an ordered sequence
         *
         * @param {Interceptor} interceptors
         * @param data
         */
        this.executeInterceptors = async (interceptors, data) => {
            if (!interceptors)
                return data;
            for (const interceptor of interceptors) {
                if (typeof interceptor === 'function') {
                    data = await interceptor(data);
                }
            }
            return data;
        };
        /**
         * Configures interceptors for a given extension
         * and returns the result
         *
         * @param config
         */
        this.configureInterceptors = (config) => {
            const mappedInterceptors = {};
            Object.entries(config).forEach(([extensionCode, extensionConfig]) => {
                if (extensionConfig === null || extensionConfig === void 0 ? void 0 : extensionConfig.interceptors) {
                    mappedInterceptors[extensionCode] = this.mapInterceptors(extensionConfig.interceptors);
                }
            });
            return mappedInterceptors;
        };
        this.config = config;
        this.eventManager = eventManager;
        this.configuredInterceptors = this.configureInterceptors(config);
    }
    /**
     * Resolves interceptor from the configuration.
     *
     * @param {string} moduleName
     * @param {string} methodName
     * @param {InterceptorType} interceptorType
     */
    getInterceptors(moduleName, methodName, interceptorType) {
        var _a, _b, _c;
        //TODO Exclusion of aroundInterceptors is needed because they are not implemented yet, should be removed when they are implemented
        return (_c = (_b = (_a = this.configuredInterceptors[moduleName]) === null || _a === void 0 ? void 0 : _a[interceptorType]) === null || _b === void 0 ? void 0 : _b[methodName]) !== null && _c !== void 0 ? _c : [];
    }
    /**
     * @param connector
     * @param {string} moduleName
     */
    setupInterceptors(connector, moduleName) {
        const methods = Object.entries(connector);
        const methodsWithInterceptors = methods.map(([fnName, fn]) => [
            fnName,
            this.applyInterceptors(fnName, fn, moduleName),
        ]);
        return Object.fromEntries(methodsWithInterceptors);
    }
    /**
     * Resolves replacement function from the configuration object.
     *
     * @param {string} moduleName
     * @param {string} methodName
     */
    getOverride(moduleName, methodName) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config[moduleName]) === null || _a === void 0 ? void 0 : _a.override) === null || _b === void 0 ? void 0 : _b[methodName]) !== null && _c !== void 0 ? _c : null;
    }
    /**
     * Structure of interceptors config object is user-friendly and looks like this:
     * interceptors: [
     *     {
     *       before: {
     *         m1: [() => 'm1+a', () => 'm1+b'],
     *         m2: () => 'm2'
     *       },
     *       after: {
     *         m1: () => 'm1-after'
     *       }
     *     },
     *     {
     *       before: {
     *         m1: () => 'm1+c',
     *         m3: () => 'm3'
     *       }
     *     },
     *     ...npmPackage1,
     *     ...npmPackage2,
     *     ...
     *   ]
     *
     * It will be internally mapped to this structure:
     * interceptors: {
     *   before: {
     *     m1: [
     *       () => 'm1+a',
     *       () => 'm1+b',
     *       () => 'm1+c'
     *     ],
     *     m2: [
     *       () => 'm2'
     *     ],
     *     m3:[
     *       () => 'm3'
     *     ]
     *   },
     *   after: {
     *     m1: [
     *       () => 'm1-after'
     *     ]
     *   }
     * }
     */
    mapInterceptors(interceptors) {
        const mappedInterceptors = {
            before: {},
            after: {},
            around: {},
        };
        interceptors.forEach((interceptor) => {
            Object.entries(interceptor).forEach(([interceptorType, interceptorMethods]) => {
                Object.entries(interceptorMethods).forEach(([methodName, methodInterceptors]) => {
                    if (!mappedInterceptors[interceptorType][methodName]) {
                        mappedInterceptors[interceptorType][methodName] = [];
                    }
                    if (Array.isArray(methodInterceptors)) {
                        mappedInterceptors[interceptorType][methodName].push(...methodInterceptors);
                    }
                    else if (typeof methodInterceptors === 'function') {
                        mappedInterceptors[interceptorType][methodName].push(methodInterceptors);
                    }
                });
            });
        });
        return mappedInterceptors;
    }
    /**
     * @param {string} moduleName
     * @param {string} methodName
     * @param {any} args
     */
    async executeBeforeInterceptors(moduleName, methodName, args) {
        const interceptors = this.getInterceptors(moduleName, methodName, 'before');
        return this.executeInterceptors(interceptors, args);
    }
    /**
     * @param {string} moduleName
     * @param {string} methodName
     * @param {any} result
     */
    async executeAfterInterceptors(moduleName, methodName, result) {
        const interceptors = this.getInterceptors(moduleName, methodName, 'after');
        return this.executeInterceptors(interceptors, result);
    }
    /**
     * Applies interceptors to connector methods.
     *
     * @param {string} fnName Name of the interceptor subject function
     * @param {any} fn Subject of the interceptor
     * @param {string} moduleName
     * @private
     */
    applyInterceptors(fnName, fn, moduleName) {
        return async (...args) => {
            var _a;
            try {
                this.eventManager.emit(`*_before`, args);
                this.eventManager.emit(`${moduleName}_before`, args);
                this.eventManager.emit(`${moduleName}_${fnName}_before`, args);
                const methodArgs = await this.executeBeforeInterceptors(moduleName, fnName, args);
                const finalFn = (_a = this.getOverride(moduleName, fnName)) !== null && _a !== void 0 ? _a : fn;
                let result = await finalFn(...methodArgs);
                result = await this.executeAfterInterceptors(moduleName, fnName, result);
                this.eventManager.emit(`*_after`, result);
                this.eventManager.emit(`${moduleName}_after`, result);
                this.eventManager.emit(`${moduleName}_${fnName}_after`, result);
                return result;
            }
            catch (err) {
                if (err instanceof Error) {
                    throw handleError(err);
                }
                else {
                    throw err;
                }
            }
        };
    }
}

/**
 * Initializes SDK
 *
 * @param sdkConfig - SDK configuration
 *
 * @example
 * This is an example of how to initialize SDK
 * Providing generic type is required to get proper type inference.
 *
 * ```typescript
 * const sdkConfig = {
 *   module1: buildModule<Module1, typeof extension>(module1, {}, extension),
 *   module2: buildModule<Module2>(module2),
 * };
 *
 * const sdk = initSDK<typeof sdkConfig>(sdkConfig);
 * ```
 */
const initSDK = (sdkConfig) => {
    const interceptorsManager = new InterceptorsManager(sdkConfig, eventManager);
    const sdk = {};
    Object.keys(sdkConfig).forEach((extensionCode) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const extend = (_b = (_a = sdkConfig[extensionCode]) === null || _a === void 0 ? void 0 : _a.extend) !== null && _b !== void 0 ? _b : {};
        const connector = Object.assign({}, (_c = sdkConfig[extensionCode].connector) !== null && _c !== void 0 ? _c : {}, extend);
        const utils = (_e = (_d = sdkConfig[extensionCode]) === null || _d === void 0 ? void 0 : _d.utils) !== null && _e !== void 0 ? _e : {};
        const subscribers = (_g = (_f = sdkConfig[extensionCode]) === null || _f === void 0 ? void 0 : _f.subscribers) !== null && _g !== void 0 ? _g : {};
        eventManager.registerSubscribers(subscribers);
        sdk[extensionCode] = {
            ...connector,
            ...interceptorsManager.setupInterceptors(connector, extensionCode),
            utils,
        };
    });
    return sdk;
};

/**
 * Performs a deep merge of objects and returns new object. Does not modify
 * objects (immutable) and merges arrays via concatenation.
 *
 * @param {...object} objects - Objects to merge
 * @returns {object} New object with merged key/values
 */
function mergeDeep(...objects) {
    const isObject = (obj) => obj && typeof obj === 'object';
    return objects.reduce((prev, obj) => {
        Object.keys(obj !== null && obj !== void 0 ? obj : {}).forEach((key) => {
            const pVal = prev[key];
            const oVal = obj[key];
            if (Array.isArray(pVal) && Array.isArray(oVal)) {
                prev[key] = pVal.concat(...oVal);
            }
            else if (isObject(pVal) && isObject(oVal)) {
                prev[key] = mergeDeep(pVal, oVal);
            }
            else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, {});
}

/**
 * Build module with extension.
 * Provide a module factory function and an extension object.
 *
 * Overloaded function:
 * - buildModule(module, moduleOptions)
 * - buildModule(module, moduleOptions, extension)
 * - buildModule(module, moduleOptions, extension, extensionOptions)
 */
function buildModule(module, moduleOptions = {}, extension, extensionOptions) {
    const resolvedExtension = typeof extension === 'function' ? extension(extensionOptions) : extension !== null && extension !== void 0 ? extension : {};
    return mergeDeep(module(moduleOptions), resolvedExtension);
}

/**
 * An old alias for initSDK function.
 *
 * @deprecated
 */
const initVSFSDK = initSDK;

exports.buildModule = buildModule;
exports.eventManager = eventManager;
exports.handleError = handleError;
exports.initSDK = initSDK;
exports.initVSFSDK = initVSFSDK;
//# sourceMappingURL=index.cjs.js.map
