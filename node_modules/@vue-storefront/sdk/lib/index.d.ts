/**
 * This file contains all types used in the SDK.
 *
 * @remarks
 * This file is used to generate the documentation for the SDK.
 * We use the {@link https://tsdoc.org/ | TSDoc} syntax.
 * When you add a new type, please add a short description and an example.
 */
/**
 * AnyFunction type represents a function that accepts any number of arguments
 * and returns any type of value.
 * It is used for the connector methods, interceptors, overrides and extensions for which
 * we don't know the exact types.
 *
 * @example
 * const fn: AnyFunction = (a, b) => a + b;
 */
declare type AnyFunction = (...args: Array<any>) => any;
/**
 * InitFunction is a function that is called when the module is initialized.
 * It contains the module options that is passed to the module and returns
 * the module.
 *
 * @example
 * const MyModule: InitFunction<Module> = (opts) => {
 * // Do something with the options
 *  return {
 *    connector: {
 *    method1: () => {},
 *   },
 *  }
 * }
 */
declare type InitFunction<T> = (opts?: any) => T;
/**
 * Alias for the AnyFunction type.
 * Used in the context of interceptors.
 *
 * @see AnyFunction
 */
declare type Interceptor = AnyFunction;
/**
 * InterceptorType represents the type of the interceptor.
 */
declare type InterceptorType = 'before' | 'after' | 'around';
/**
 * InterceptorsConfig represents the configuration of the interceptors.
 * It is a map of the interceptor type to the map of the method name to the interceptor.
 *
 * @example
 * const interceptorsConfig: InterceptorsConfig = {
 *  before: {
 *    method1: [interceptor1, interceptor2],
 *    method2: interceptor3,
 *  },
 *  after: {
 *    method1: [interceptor1, interceptor2],
 *    method2: interceptor3,
 *  },
 *  around: {
 *    method1: [interceptor1, interceptor2],
 *    method2: interceptor3,
 *  },
 *};
 */
declare type InterceptorsConfig = {
    [type in InterceptorType]?: Record<string, Interceptor | Array<Interceptor> | undefined>;
};
/**
 * MappedInterceptors represents the interceptors mapped to the methods.
 * Used internally by the SDK.
 *
 * @internal
 */
declare type MappedInterceptors = Record<string, Record<string, Array<Interceptor>>>;
/**
 * Utility type that defines the type of arguments that are passed to the `before` interceptor.
 */
declare type InterceptorArgsBefore<ARGS extends AnyFunction> = Parameters<ARGS>;
/**
 * Utility type that defines the type of the result that is returned from the `before` interceptor.
 */
declare type InterceptorResultBefore<ARGS extends AnyFunction> = Promise<Parameters<ARGS>>;
/**
 * Utility type that defines the type of arguments that are passed to the `after` interceptor.
 */
declare type InterceptorArgsAfter<RESULT extends AnyFunction> = Awaited<ReturnType<RESULT>>;
/**
 * Utility type that defines the type of the result that is returned from the `after` interceptor.
 */
declare type InterceptorResultAfter<RESULT extends AnyFunction> = Promise<ReturnType<RESULT>>;
/**
 * EventCallback is a function that is called when an event is emitted.
 */
declare type EventCallback = <T>(...data: Array<T>) => void;
/**
 * Subscribers are declarative callbacks that are called when an event is emitted.
 */
declare type Subscribers = Record<string, EventCallback | Array<EventCallback>>;
/**
 * Connector returns all methods that are exposed by the module.
 */
declare type Connector = Record<string, AnyFunction>;
/**
 * Module Type represents the module configuration.
 * It is a pluggable piece of code in a standalone package.
 * Module can be a subject of interceptors, overrides and extensions.
 */
declare type Module = {
    /**
     * Connector returns all methods that are exposed by the module.
     * Each method must be an asynchronous function.
     * The connector is called only once when the module is initialized.
     * It can be used to create proxies for the methods.
     */
    connector: Connector;
    /**
     * Small pieces of code that can be used by the module and external packages.
     * Utils functions can be asynchronous or synchronous.
     * Functions should be small and reusable.
     */
    utils?: Record<string, any>;
    /**
     * Subscribers are declarative callbacks that are called when an event is emitted.
     * Subscribers mustn't modify the arguments or return any value.
     *
     * @see Subscribers
     *
     * @example
     * Registering a subscriber for the event MyModule_Method1_before.
     *
     *```typescript
     * const subscribers: Subscribers = {
     *  MyModule_Method1_before: (args) => {
     *    // do something with the arguments
     *    console.log('MyModule_Method1_before input arguments', args);
     *  }
     *```
     */
    subscribers?: Subscribers;
};
/**
 * Extension Type represents the extension configuration.
 * It provides extensibility mechanisms like interceptors, extensions, overrides, and pub/sub manager.
 */
declare type Extension = Omit<Partial<Module>, 'connector'> & {
    /**
     * Extend contains methods that are added to the module.
     * Because of the dynamic nature of the SDK, the extend method must be an asynchronous function.
     * Extending methods can't be used to override the connector.
     *
     * @example
     * Extending the module with a new method.
     * ```typescript
     * const extension: Extension = {
     *  extend: {
     *   getBlueProducts: async () => {
     *     const products = await client.getProducts({ color: 'blue'});
     *   }
     *  }
     * }
     * ```
     * Such function will be available in the SDK API under the module namespace.
     * ```typescript
     * sdk.mymodule.getBlueProducts();
     * ```
     */
    extend?: Record<string, AnyFunction>;
    /**
     * Override contains methods that are replaced in the module.
     * Because of the dynamic nature of the SDK, the override method must be an asynchronous function.
     * Override function must fulfill the same interface as the original method.
     * Providing generic types for the function is recommended to preserve the original method signature.
     *
     * @example
     * Overriding the module method.
     * Assume that the module has a method called getProducts.
     *
     * ```typescript
     * const extension: Extension = {
     * override: {
     *  getProducts: async (args: Parameters<getProducts>): ReturnType<getProducts> => {
     *     const products = await client.getProducts({ color: 'blue'});
     *     // Execute some logic that the original method doesn't have.
     *     return products;
     *  }
     * }
     * ```
     */
    override?: Record<string, AnyFunction>;
    /**
     * Interceptors are functions that are called before, after or around the method
     * and can be used to modify the input and output of the method but also
     * to add logging, validation, error handling, etc.
     * Each interceptor must be an asynchronous function.
     * Each interceptor must fulfill the same interface as the original method.
     *
     * @see InterceptorsConfig
     */
    interceptors?: Array<InterceptorsConfig>;
};
/**
 * SDKConfig represents the configuration and the API of the SDK.
 */
declare type SDKConfig = Readonly<Record<string, Module> & Record<string, Extension>>;
/**
 * SDKApi represents the API of the SDK.
 * On the init SDK transform configuration data to compose an API and apply interceptors
 * to all methods. This requires a dynamic type mapping to provide the user
 * with the best possible developer experience.
 *
 * The following type map understand the SDK configuration input and produce
 * usable SDK api with all type hints.
 */
declare type SDKApi<Config extends SDKConfig> = {
    [ExtensionName in keyof Config]: {
        +readonly [Method in keyof Config[ExtensionName]['connector'] | keyof Config[ExtensionName]['override']]: Method extends keyof Config[ExtensionName]['override'] ? Config[ExtensionName]['override'][Method] : Config[ExtensionName]['connector'][Method];
    } & {
        +readonly [Method in keyof Config[ExtensionName]['extend']]: Config[ExtensionName]['extend'][Method];
    };
} & {
    +readonly [ExtensionName in keyof Config]: {
        utils: {
            +readonly [Method in keyof Config[ExtensionName]['utils']]: Config[ExtensionName]['utils'][Method];
        };
    };
};

/**
 * Initializes SDK
 *
 * @param sdkConfig - SDK configuration
 *
 * @example
 * This is an example of how to initialize SDK
 * Providing generic type is required to get proper type inference.
 *
 * ```typescript
 * const sdkConfig = {
 *   module1: buildModule<Module1, typeof extension>(module1, {}, extension),
 *   module2: buildModule<Module2>(module2),
 * };
 *
 * const sdk = initSDK<typeof sdkConfig>(sdkConfig);
 * ```
 */
declare const initSDK: <T extends Readonly<Record<string, Module> & Record<string, Extension>>>(sdkConfig: T) => SDKApi<T>;

/**
 * EventManagerInterface is an interface used to emit and subscribe to events.
 */
interface EventManagerInterface {
    /**
     * Function that emits an event.
     * It calls all the callbacks that are registered for the given topic.
     *
     * @param topic - topic of the event
     * @param data - data that is passed to the callbacks
     */
    emit<EVENT_DATA>(topic: string, data: Readonly<EVENT_DATA>): void;
    /**
     * Function that registers a callback for a given topic.
     * It can be used to register a single callback or an array of callbacks.
     *
     * @param topic - topic of the event
     * @param callback - callback that is called when the event is emitted
     */
    register(topic: string, callback: EventCallback): void;
    /**
     * Function that registers a callback for a given topic.
     * It can be used to register a single callback or an array of callbacks.
     *
     * @param topic - topic of the event
     * @param callback - array of callbacks that are called when the event is emitted
     */
    register(topic: string, callback: Array<EventCallback>): void;
    /**
     * Function that unregisters a callback for a given topic.
     *
     * @param topic - topic of the event
     * @param callback - callback that is called when the event is emitted
     */
    unregister(topic: string, callback: EventCallback): void;
    /**
     * Function that registers multiple callbacks for multiple topics (Subscribers).
     * @param subscribers
     */
    registerSubscribers(subscribers: Subscribers): void;
}
/**
 * EventManager is a class that is used to emit and subscribe to events.
 *
 * @example
 * You can use it to emit an event:
 * ```typescript
 * const eventManager = new EventManager();
 * eventManager.emit('my_event_name', { foo: 'bar' });
 * ```
 *
 * You can use it to register a callback for an event:
 * ```typescript
 * const eventManager = new EventManager();
 * eventManager.register('my_event_name', (data) => {
 *   console.log(data);
 *   // { foo: 'bar' }
 *   // ...
 * });
 */
declare class EventManager implements EventManagerInterface {
    /**
     * Object that contains all the registered callbacks for each topic.
     *
     * @readonly
     * @private
     */
    private readonly events;
    constructor();
    emit<EVENT_DATA>(topic: string, data: Readonly<EVENT_DATA>): void;
    register(topic: string, callback: EventCallback | Array<EventCallback>): void;
    unregister(topic: string, callback: EventCallback): void;
    registerSubscribers(subscribers: Subscribers): void;
}
declare const eventManager: EventManager;

declare function buildModule<T extends Module>(module: InitFunction<T>, moduleOptions?: any): T;
declare function buildModule<T extends Module, U extends Extension = object>(module: InitFunction<T>, moduleOptions: any): T & U;
declare function buildModule<T extends Module, U extends Extension = object>(module: InitFunction<T>, moduleOptions: any, extension: U): T & U;
declare function buildModule<T extends Module, U extends Extension = object>(module: InitFunction<T>, moduleOptions: any, extension?: InitFunction<U> | U, extensionOptions?: object): T & U;

declare class SDKError extends Error {
    cause: unknown;
    constructor(message: string, cause: unknown);
}
declare const handleError: (err: Error) => SDKError;

/**
 * An old alias for initSDK function.
 *
 * @deprecated
 */
declare const initVSFSDK: <T extends Readonly<Record<string, Module> & Record<string, Extension>>>(sdkConfig: T) => SDKApi<T>;

export { AnyFunction, Connector, EventCallback, Extension, InitFunction, Interceptor, InterceptorArgsAfter, InterceptorArgsBefore, InterceptorResultAfter, InterceptorResultBefore, InterceptorType, InterceptorsConfig, MappedInterceptors, Module, SDKApi, SDKConfig, Subscribers, buildModule, eventManager, handleError, initSDK, initVSFSDK };
