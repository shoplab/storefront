'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var consola = require('consola');
var cookieParser = require('cookie-parser');
var cors = require('cors');
var express = require('express');
var helmet = require('helmet');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var consola__default = /*#__PURE__*/_interopDefaultLegacy(consola);
var cookieParser__default = /*#__PURE__*/_interopDefaultLegacy(cookieParser);
var cors__default = /*#__PURE__*/_interopDefaultLegacy(cors);
var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var helmet__default = /*#__PURE__*/_interopDefaultLegacy(helmet);

/**
 * Resolves dependencies based on the current working directory, not relative to this package.
 */
function resolveDependency(name) {
    try {
        // eslint-disable-next-line
        return require(require.resolve(name, { paths: [process.cwd()] }));
    }
    catch (error) {
        consola__default["default"].error(error);
        throw new Error(`Could not resolve integration "${name}". See the error above for more details.`);
    }
}

/**
 * Imports extensions from the current working directory if they're represented as strings.
 */
function lookUpExternal(extension) {
    return typeof extension === "string"
        ? resolveDependency(extension)
        : [extension];
}

/**
 * Imports extensions if they're represented as strings.
 */
function createExtensions(rawExtensions) {
    return rawExtensions.flatMap(lookUpExternal);
}
/**
 * Creates an array of extensions schemas or their paths.
 */
function createRawExtensions(apiClient, integration) {
    const extensionsCreateFn = integration.extensions;
    const predefinedExtensions = apiClient.createApiClient._predefinedExtensions || [];
    return extensionsCreateFn
        ? extensionsCreateFn(predefinedExtensions)
        : predefinedExtensions;
}

const isFunction = (x) => typeof x === "function";
// eslint-disable-next-line no-use-before-define
function includes(coll, el) {
    return coll.includes(el);
}

const STATUS_FIELDS = ["status", "statusCode"];
function isErrorObject(obj) {
    // typeof null is 'object' https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null
    if (obj === null)
        return false;
    return typeof obj === "object";
}
function isAxiosError(error) {
    return "isAxiosError" in error;
}
function isApolloError(error) {
    return "networkError" in error || "code" in error;
}
function reduceStatus(narrowObject, depth) {
    return function reduceStatusNested(statusCode, key) {
        if (statusCode) {
            return statusCode;
        }
        if (includes(STATUS_FIELDS, key)) {
            return narrowObject[key] || null;
        }
        const newDepth = depth + 1;
        // eslint-disable-next-line no-use-before-define
        return obtainStatusCode(narrowObject[key], newDepth);
    };
}
function obtainStatusCode(givenObject, depth = 1) {
    const obj = givenObject || {};
    if (depth > 3) {
        return null;
    }
    return Object.keys(obj).reduce(reduceStatus(obj, depth), null);
}
function getAxiosStatusCode(error) {
    return error.response.status;
}
function getApolloStatusCode(error) {
    if (error.networkError) {
        return 500;
    }
    if (error.code) {
        return typeof error.code === "string" ? 400 : error.code;
    }
    return undefined;
}
function getCodeFromError(error) {
    if (!isErrorObject(error)) {
        return undefined;
    }
    if (isAxiosError(error)) {
        return getAxiosStatusCode(error);
    }
    if (isApolloError(error)) {
        return getApolloStatusCode(error);
    }
    return obtainStatusCode(error);
}
function getAgnosticStatusCode(error) {
    return getCodeFromError(error) || 500;
}

async function getInitConfig({ apiClient, tag, integration, }) {
    if (isFunction(apiClient?.init)) {
        try {
            consola__default["default"].success(`- Integration: ${tag} init function Start!`);
            const initConfig = await apiClient.init(integration.configuration);
            consola__default["default"].success(`- Integration: ${tag} init function Done!`);
            return initConfig;
        }
        catch (error) {
            throw Error(`Error during executing init function in ${tag} integration. Error message: ${error}`);
        }
    }
    return {};
}

/**
 * Default error handler for the middleware
 *
 * @param error
 * @param req
 * @param res
 */
const defaultErrorHandler = (error, req, res) => {
    consola__default["default"].error(error);
    const status = getAgnosticStatusCode(error);
    res.status(status);
    if (status >= 400 && status < 500) {
        /**
         * For all 4xx error codes or client error codes we wanted to send the error message
         */
        res.send(error);
    }
    else {
        /**
         * For all other error codes we wanted to send a generic error message
         */
        res.send("ServerError: Something went wrong. Please, check the logs for more details.");
    }
};

async function registerIntegrations(app, integrations) {
    return await Object.entries(integrations).reduce(async (prevAsync, [tag, integration]) => {
        consola__default["default"].info(`- Loading: ${tag} ${integration.location}`);
        const prev = await prevAsync;
        const apiClient = resolveDependency(integration.location);
        const rawExtensions = createRawExtensions(apiClient, integration);
        const extensions = createExtensions(rawExtensions);
        const initConfig = await getInitConfig({ apiClient, integration, tag });
        const configuration = {
            ...integration.configuration,
            integrationName: tag,
        };
        for (const { name, extendApp } of extensions) {
            consola__default["default"].info(`- Loading: ${tag} extension: ${name}`);
            if (extendApp) {
                await extendApp({ app, configuration });
            }
        }
        consola__default["default"].success(`- Integration: ${tag} loaded!`);
        return {
            ...prev,
            [tag]: {
                apiClient,
                extensions,
                initConfig,
                configuration,
                customQueries: integration.customQueries,
                errorHandler: integration.errorHandler ?? defaultErrorHandler,
            },
        };
    }, Promise.resolve({}));
}

async function callApiFunction(req, res) {
    const { apiFunction, args, errorHandler } = res.locals;
    try {
        const platformResponse = await apiFunction(...args);
        res.send(platformResponse);
    }
    catch (error) {
        errorHandler(error, req, res);
    }
}

function prepareApiFunction(integrations) {
    return (req, res, next) => {
        const { integrationName, functionName } = req.params;
        if (!integrations || !integrations[integrationName]) {
            res.status(404);
            res.send(`"${integrationName}" integration is not configured. Please, check the request path or integration configuration.`);
            return;
        }
        const { apiClient, configuration, extensions, customQueries = {}, initConfig, } = integrations[integrationName];
        const middlewareContext = {
            req,
            res,
            extensions,
            customQueries,
            integrations,
            getApiClient: (integrationKey) => {
                if (!(integrationKey in integrations)) {
                    const keys = Object.keys(integrations);
                    throw new Error(`The specified integration key "${integrationKey}" was not found. Available integration keys are: ${keys}. Please ensure you're using the correct key or add the necessary integration configuration.`);
                }
                const { apiClient: innerApiClient, configuration: innerConfiguration, extensions: innerExtensions, customQueries: innerCustomQueries = {}, initConfig: innerInitConfig, } = integrations[integrationKey];
                const innerMiddlewareContext = {
                    ...middlewareContext,
                    extensions: innerExtensions,
                    customQueries: innerCustomQueries,
                };
                const createInnerApiClient = innerApiClient.createApiClient.bind({
                    middleware: innerMiddlewareContext,
                });
                const apiClientInstance = createInnerApiClient({
                    ...innerConfiguration,
                    ...innerInitConfig,
                });
                return apiClientInstance;
            },
        };
        const createApiClient = apiClient.createApiClient.bind({
            middleware: middlewareContext,
        });
        const apiClientInstance = createApiClient({
            ...configuration,
            ...initConfig,
        });
        const apiFunction = apiClientInstance.api[functionName];
        res.locals.apiFunction = apiFunction;
        next();
    };
}

function prepareErrorHandler(integrations) {
    return (req, res, next) => {
        const { integrationName } = req.params;
        const { errorHandler } = integrations[integrationName];
        res.locals.errorHandler = errorHandler;
        next();
    };
}

function prepareArguments(req, res, next) {
    const { method, query, body } = req;
    let args;
    if (method === "GET") {
        /**
         * Falling back to empty object to mimic
         * the behavior of express.json() middleware
         * when no POST body is provided.
         */
        const { body: queryBody = "{}" } = query;
        args = JSON.parse(queryBody);
    }
    else {
        args = body;
    }
    const argsArray = Symbol.iterator in Object(args) ? args : [args];
    res.locals.args = argsArray;
    next();
}

async function createServer(config) {
    const app = express__default["default"]();
    app.use(express__default["default"].json());
    app.use(cookieParser__default["default"]());
    app.use(cors__default["default"]({
        credentials: true,
        origin: "http://localhost:3000",
    }));
    app.disable("x-powered-by");
    consola__default["default"].info("Middleware starting....");
    const options = {
        contentSecurityPolicy: false,
        crossOriginOpenerPolicy: false,
        crossOriginEmbedderPolicy: false,
        permittedCrossDomainPolicies: {
            permittedPolicies: "none",
        },
        ...(config.helmet || {}),
    };
    const isHelmetEnabled = config.helmet === true ||
        (config.helmet && Object.keys(config.helmet).length > 0);
    if (isHelmetEnabled) {
        app.use(helmet__default["default"](options));
        consola__default["default"].info("VSF `Helmet` middleware added");
    }
    consola__default["default"].info("Loading integrations...");
    const integrations = await registerIntegrations(app, config.integrations);
    consola__default["default"].success("Integrations loaded!");
    app.post("/:integrationName/:functionName", prepareApiFunction(integrations), prepareErrorHandler(integrations), prepareArguments, callApiFunction);
    app.get("/:integrationName/:functionName", prepareApiFunction(integrations), prepareErrorHandler(integrations), prepareArguments, callApiFunction);
    app.get("/healthz", (_req, res) => {
        res.end("ok");
    });
    consola__default["default"].success("Middleware created!");
    return app;
}

const createExtendQuery = (context) => (customQuery, defaults) => {
    const { customQueries = {} } = context;
    const { metadata = {} } = customQuery || {};
    return Object.entries(defaults).reduce((prev, [queryName, initialArgs]) => {
        const key = customQuery?.[queryName];
        const queryFn = (key && customQueries[key]) || (() => initialArgs);
        return {
            ...prev,
            [queryName]: queryFn({ ...initialArgs, metadata }),
        };
    }, {});
};

// @ts-check
const nopBefore = ({ args }) => args;
const nopAfter = ({ response, }) => response;
/**
 * Wraps api methods with context and hooks triggers
 */
const applyContextToApi = (api, context, 
/**
 * By default we use NOP function for returning the same parameters as they come.
 * It's useful in extensions, when someone don't want to inject into changing arguments or the response,
 * in that case, we use default function, to handle that scenario - NOP
 */
hooks = { before: nopBefore, after: nopAfter }) => Object.entries(api).reduce((prev, [callName, fn]) => ({
    ...prev,
    [callName]: async (...args) => {
        const extendQuery = createExtendQuery(context);
        const transformedArgs = hooks.before({ callName, args });
        const apiClientContext = { ...context, extendQuery };
        const response = await fn(apiClientContext, ...transformedArgs);
        const transformedResponse = hooks.after({ callName, args, response });
        return transformedResponse;
    },
}), {});

const apiClientFactory = (factoryParams) => {
    const createApiClient = function createApiClient(config, customApi = {}) {
        const rawExtensions = this?.middleware?.extensions || [];
        const lifecycles = rawExtensions
            .filter((extension) => isFunction(extension?.hooks))
            .map(({ hooks }) => hooks(this?.middleware?.req, this?.middleware?.res));
        const extendedApis = rawExtensions.reduce((prev, { extendApiMethods }) => ({ ...prev, ...extendApiMethods }), customApi);
        const _config = lifecycles
            .filter((extension) => isFunction(extension?.beforeCreate))
            .reduce((configSoFar, extension) => extension.beforeCreate({ configuration: configSoFar }), config);
        const settings = factoryParams.onCreate
            ? factoryParams.onCreate(_config)
            : { config, client: config.client };
        settings.config = lifecycles
            .filter((extension) => isFunction(extension?.afterCreate))
            .reduce((configSoFar, extension) => extension.afterCreate({ configuration: configSoFar }), settings.config);
        const extensionHooks = {
            before: (params) => lifecycles
                .filter((extension) => isFunction(extension?.beforeCall))
                .reduce((args, extension) => extension.beforeCall({
                ...params,
                configuration: settings.config,
                args,
            }), params.args),
            after: (params) => lifecycles
                .filter((extension) => isFunction(extension.afterCall))
                .reduce((response, extension) => extension.afterCall({
                ...params,
                configuration: settings.config,
                response,
            }), params.response),
        };
        const context = { ...settings, ...(this?.middleware || {}) };
        const { api: apiOrApiFactory = {} } = factoryParams;
        const isApiFactory = typeof apiOrApiFactory === "function";
        const api = isApiFactory ? apiOrApiFactory(settings) : apiOrApiFactory;
        /**
         * FIXME IN-3487
         *
         * `applyContextToApi` requires `context` to be of type `MiddlewareContext`
         * However, the above `const context =` does not satisfy that type.
         *
         * `this.middleware` provides (among others) `{ req: ..., res: ..., ... }`,
         * but `this?.middleware || {}` provides `{ req?: ..., res?: ..., ...}`
         *
         * `MiddlewareContext` requires `req` and `res` to be required, not optional, hence the error.
         */
        // @ts-expect-error see above
        const integrationApi = applyContextToApi(api, context, extensionHooks);
        const extensionsApi = applyContextToApi(extendedApis ?? {}, 
        // @ts-expect-error see above
        context, extensionHooks);
        const mergedApi = {
            ...integrationApi,
            ...extensionsApi,
        };
        // api methods haven't been invoked yet, so we still have time to add them to the context
        context.api = integrationApi;
        return {
            api: mergedApi,
            client: settings.client,
            settings: settings.config,
        };
    };
    createApiClient._predefinedExtensions = factoryParams.extensions || [];
    return { createApiClient };
};

exports.apiClientFactory = apiClientFactory;
exports.createServer = createServer;
//# sourceMappingURL=index.cjs.js.map
